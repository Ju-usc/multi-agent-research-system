"""
Multi-Agent Research System - Async Implementation
Implements Anthropic's orchestrator-worker architecture with async DSPy
"""

import os
import asyncio
from typing import List, Dict, Optional, Literal
from enum import Enum
from pydantic import BaseModel, Field
import dspy
from dspy.adapters import JSONAdapter
import wikipedia
from brave_search_python_client import BraveSearch, WebSearchRequest
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configuration
BRAVE_SEARCH_API_KEY = os.getenv("BRAVE_SEARCH_API_KEY")
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
OPENROUTER_BASE_URL = os.getenv("OPENROUTER_BASE_URL")

SMALL_MODEL = os.getenv("GEMINI_2.5_FLASH_LITE")
BIG_MODEL = os.getenv("GPT_4.1_MINI")

TEMPERATURE = float(os.getenv("TEMPERATURE", "1.0"))
MAX_TOKENS = int(os.getenv("MAX_TOKENS", "4000"))

# ---------- Data Models (Unchanged) ----------

class SubagentTask(BaseModel):
    """Atomic research micro-task allocated to one sub-agent in the plan."""
    id: int = Field(description="Stable identifier used to track this task across iterations")
    objective: str = Field(description="Crisp single-focus goal the subagent must accomplish")
    tool_guidance: Dict[Literal["web_search", "wikipedia_search", "parallel_search"], str] = Field(description="Mapping of allowed tool names to concise usage instructions")
    tool_budget: int = Field(default=8, ge=3, le=15, description="Maximum number of tool calls the subagent may issue")
    expected_output: str = Field(description="Exact artifact or information the subagent must return for completion")
    tip: Optional[str] = Field(default=None, description="Optional hint to improve quality or efficiency while executing the task")


class SubagentResult(BaseModel):
    """Structured report a subagent returns after finishing its task."""
    task_id: int = Field(description="Identifier of the task that produced this result")
    summary: str = Field(description="High-density 2-4 sentence overview of the key findings")
    finding: str = Field(description="Full detailed answer directly addressing the task objective")
    debug_info: Optional[List[str]] = Field(default=None, description="Optional list of raw tool call traces for debugging")


class ResearchMemory(BaseModel):
    """Persisted snapshot of strategy, pending tasks and findings that survives long sessions."""
    query: str = Field(description="Original user question guiding the research")
    reasoning: str = Field(description="Lead agent's extended thinking and strategic rationale")
    tasks: List[SubagentTask] = Field(description="All tasks that remain to be executed or are in progress")
    current_findings: str = Field(default="", description="Synthesized insights accumulated so far")

# ---------- DSPy Signatures (Unchanged) ----------

class PlanResearch(dspy.Signature):
    """Generate strategic reasoning and a parallel task list for subagents from the user's query."""
    query: str = dspy.InputField(desc="Original user question providing context")
    current_findings: str = dspy.InputField(default="", desc="Accumulated insights from earlier iterations")
    reasoning: str = dspy.OutputField(desc="Extended strategic thinking to persist in memory")
    tasks: List[SubagentTask] = dspy.OutputField(desc="Complete list of SubagentTask objects to execute in parallel")

class ExecuteSubagentTask(dspy.Signature):
    """Run one subagent task with its tools and return a structured result."""
    task: SubagentTask = dspy.InputField(desc="SubagentTask definition to be executed")
    final_result: SubagentResult = dspy.OutputField(desc="Structured outcome generated by the subagent")
    reasoning: str = dspy.OutputField(desc="Subagent's internal rationale for the result")

class SynthesizeAndDecide(dspy.Signature):
    """Aggregate results, update findings, and signal whether to finish, continue, or replan."""
    query: str = dspy.InputField(desc="Original user question guiding evaluation")
    current_findings: str = dspy.InputField(default="", desc="Previously synthesized insights to extend")
    completed_results: List[SubagentResult] = dspy.InputField(desc="List of SubagentResult objects ready for synthesis")
    synthesis: str = dspy.OutputField(desc="New consolidated insights from the completed results")
    next_action: Literal["DONE", "CONTINUE", "REPLAN"] = dspy.OutputField(desc="Control signal indicating next step")
    final_answer: Optional[str] = dspy.OutputField(desc="Definitive answer when next_action is DONE")

# ---------- Async Tool Implementations ----------

async def web_search(query: str, count: int = 5) -> str:
    """Search the web using Brave Search.
    
    Args:
        query: Search query
        count: Number of results (default: 5)
        
    Returns:
        Formatted search results
    """
    if count > 5:
        count = 5
    
    client = BraveSearch(api_key=BRAVE_SEARCH_API_KEY)
    
    try:
        response = await client.web(WebSearchRequest(q=query, count=count))
        
        if not response.web or not response.web.results:
            return f"No results found for '{query}'"

        results = []
        for i, result in enumerate(response.web.results[:count], 1):
            results.append(f"{i}. {result.title}\\n   {result.description}\\n   {result.url}")
        
        return f"Search results for '{query}':\\n\\n" + "\\n\\n".join(results)
    except Exception as e:
        return f"Search error: {e}"


def wikipedia_search(query: str, sentences: int = 3) -> str:
    """
    Return a concise English summary for `query` (≤ `sentences` sentences).

    If Wikipedia returns multiple possible pages (disambiguation), we list the
    top 5 options so the calling agent can decide what to do next.
    """
    try:
        wikipedia.set_lang("en")
        titles = wikipedia.search(query, results=1)
        if not titles:
            return f"No Wikipedia article found for '{query}'."

        title = titles[0]
        summary = wikipedia.summary(title, sentences=sentences, auto_suggest=False)
        return f"Wikipedia – {title}\\n\\n{summary}"

    except wikipedia.exceptions.DisambiguationError as e:
        # Show a short disambiguation list
        opts = "\\n • ".join(e.options[:5])
        return f"Wikipedia disambiguation for '{query}'. Try one of:\\n • {opts}"
    except Exception as err:
        return f"Wikipedia error: {err}"


async def async_batch_call(calls: list[dict]) -> list[str]:
    """
    Execute multiple tool calls in parallel for efficiency using async.
    
    Args:
        calls: List of dicts, each with:
            - tool_name: Name of the tool ('web_search' or 'wikipedia_search')
            - args: Dictionary of arguments for that tool
            
    Example:
        calls = [
            {"tool_name": "web_search", "args": {"query": "Lamine Yamal stats", "count": 2}},
            {"tool_name": "web_search", "args": {"query": "Desire Doue stats", "count": 2}},
            {"tool_name": "wikipedia_search", "args": {"query": "Lamine Yamal", "sentences": 5}},
            {"tool_name": "wikipedia_search", "args": {"query": "Desire Doue", "sentences": 5}}
        ]
    
    Returns:
        List of results in the same order as input calls
    """
    tasks = []
    formatted_results = []
    
    for call in calls:
        tool_name = call.get("tool_name")
        args = call.get("args", {})
        
        if tool_name == "web_search":
            # Async function - call directly
            task = web_search(**args)
        elif tool_name == "wikipedia_search":
            # Sync function - run in thread pool
            task = asyncio.to_thread(wikipedia_search, **args)
        else:
            # Invalid tool
            formatted_results.append(f"[ERROR] Unknown tool: {tool_name}")
            continue

        tasks.append(task)
    
    # Execute all tasks concurrently with error handling
    # return_exceptions=True ensures failed tools don't crash everything
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # Format results with tool names
    for i, output in enumerate(results):
        tool_name = calls[i].get("tool_name", "unknown")
        if isinstance(output, Exception):
            # Convert exception to string so LLM can reason about the failure
            error_msg = f"[ERROR] {type(output).__name__}: {str(output)}"
            formatted_results.append(f"{tool_name}: {error_msg}")
        else:
            formatted_results.append(f"{tool_name}: {output}")
    
    return formatted_results


# Register tools with DSPy
TOOLS = {
    "web_search": dspy.Tool(web_search),
    "wikipedia_search": dspy.Tool(wikipedia_search),
    "parallel_search": dspy.Tool(
        async_batch_call,
        name="parallel_search",
        desc="Run multiple searches in parallel. Provide tool_name ('web_search' or 'wikipedia_search') and args for each call."
    ),
    "quick_search": dspy.Tool(
        web_search,
        name="quick_search",
        desc="Single quick search to check information availability. Max 2 results."
    )
}


# ---------- Lead Agent DSPy Modules ----------

class LeadAgent(dspy.Module):
    """Lead agent: plans once, launches parallel subagents, synthesizes, then decides."""

    def __init__(self):
        super().__init__()

        # Language models
        planner_lm = dspy.LM(
            model=BIG_MODEL,
            api_key=OPENROUTER_API_KEY,
            api_base=OPENROUTER_BASE_URL,
            temperature=TEMPERATURE,
            max_tokens=MAX_TOKENS,
        )

        subagent_lm = dspy.LM(
            model=BIG_MODEL,
            api_key=OPENROUTER_API_KEY,
            api_base=OPENROUTER_BASE_URL,
            temperature=TEMPERATURE,
            max_tokens=MAX_TOKENS,
        )

        # Planner (can use quick reconnaissance tools if helpful)
        with dspy.settings.context(lm=planner_lm):
            planning_tools = [TOOLS["parallel_search"], TOOLS["quick_search"]]
            self.planner = dspy.ReAct(PlanResearch, tools=planning_tools, max_iters=3)

            # Synthesizer doesn't need tools
            self.synthesizer = dspy.ChainOfThought(SynthesizeAndDecide)

    async def aforward(self, query: str, current_findings: str = ""):
        """Plan → execute tasks in parallel → synthesize/decide (single cycle)."""

        # 1. Generate plan
        plan = await self.planner.acall(query=query, current_findings=current_findings)

        # 2. Launch subagents in parallel
        task_calls = []
        for task in plan.tasks:
            permitted_tools = [TOOLS[name] for name in task.tool_guidance.keys() if name in TOOLS]
            with dspy.settings.context(lm=self.subagent_lm):
                sub = dspy.ReAct(ExecuteSubagentTask, tools=permitted_tools, max_iters=task.tool_budget)
            task_calls.append(sub.acall(task=task))

        raw_results = await asyncio.gather(*task_calls, return_exceptions=True)
        results = [r.final_result for r in raw_results if hasattr(r, "final_result")]

        # 3. Synthesize and decide
        decision = await self.synthesizer.acall(
            query=query,
            current_findings=current_findings,
            completed_results=results
        )

        return {
            "next_action": decision.next_action,
            "final_answer": decision.final_answer,
            "synthesis": decision.synthesis,
            "results": results
        }

    async def run(self, query: str):
        """Runs a single minimal-cycle research and returns the best available answer."""
        outcome = await self.aforward(query)
        return outcome["final_answer"] or outcome["synthesis"]
    

